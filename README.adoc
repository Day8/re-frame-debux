# Debux
:source-language: clojure
:source-highlighter: coderay
:sectnums:
:imagesdir: ./doc/img
:toc:

link:https://github.com/philoskim/debux[*Debux*] is a simple but useful library for debugging Clojure and ClojureScript. *re-frame-debux* is a fork of debux, that repurposes it for tracing re-frame event and subscription handlers, and integration with link:https://github.com/Day8/re-frame-10x[re-frame-10x] and re-frame's tracing API.

Longer term, we would like to investigate merging back into mainline debux, but the changes we needed to make required quite deep surgery, so in the interests of time, we started off with this fork.

## Prerequisites

* clojure 1.8.0 or later
* clojurescript 1.9.854 or later


## Installation

To include *debux* in your project, simply add the following to your *project.clj*
dependencies:


[source]
....
[day8.re-frame/debux "0.5.0"] ;; not released yet
....

## How to use

re-frame-debux provides three macros for you to use to trace your re-frame event and subscription handlers:

* traced-fn
* traced-defn
* trace

traced-fn and traced-defn replace fn and defn respectively. trace is for places where it is not easy or possible to use the other two macros.

All three have zero runtime cost in production builds, and are able to be turned off at dev time too, so you can leave your code tracing in at all times.


## How to use

In Clojure, the following line should be included in your file.


[source]
....
(use 'debux.core)
....

In ClojureScript, the following `(:require pass:q[...])` line has to be included in your
file.


[source]
.example/core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]]))
....

{empty} +

[cols="^1m,^1m,^1m,^1m,^1m,^1m", options="header"]
.Debugging API use

|===

|                               | dbg | dbgn | clog | clogn | break

| Clojure REPL                  | O   |   O   |  X   |  X   |   X
| ClojureScript Browser REPL    | O   |   O   |  X   |  X   |   X
| ClojureScript Browser console | O   |   O   |  O   |  O   |   O

|===

* Legend: `O` (supported), `X` (not supported)

//-

. `dbg`/`dbgn` can be used in Clojure REPL.

. `dbg`/`dbgn` can be used in ClojureScript browser REPL like
  link:https://github.com/tomjakubowski/weasel[weasel] or
  https://github.com/bhauman/lein-figwheel[figwheel].

** Refer to <<browser-repl>> for Browser REPL usage.

. `dbg`/`dbgn` , `clog`/`clogn` and `break` can be used in the browser console window
  like Google DevTool.
+

TIP: I recommend that you should use `clog`/`clogn` instead of `dbg`/`dbgn` in the browser
     console window, because `clog`/`clogn` uses the `console.log` function of browser's
     developer tools to style the form.


## `dbgn` examples

NOTE: The features of `clogn` are almost the same as those of `dbgn`.

The macro `dbgn` is for Clojure/CloujureScript REPL and the macro `clogn` is for
ClojureScript browser console only. The appended *n* to these two macro names means
**N**ested forms. You can debug every nested form without interrupting code
evaluations. This feature is very useful, especially when you analyze other developer's
source code.


### Simple example

[source]
....
(dbgn (defn foo [a b & [c]]
        (if c
          (* a b c)
          (* a b 100))))

(foo 2 3)
; => 600

(foo 2 3 10)
; => 60
....

[listing]
.REPL output
----
dbgn: (defn foo [a b & [c]] (if c (* a b c) (* a b 100))) =>

| c =>
|   nil
| a =>
|   2
| b =>
|   3
| (* a b 100) =>
|   600
| (if c (* a b c) (* a b 100)) =>
|   600

| c =>
|   10
| a =>
|   2
| b =>
|   3
| c =>
|   10
| (* a b c) =>
|   60
| (if c (* a b c) (* a b 100)) =>
|   60
----


### Detailed examples

* `dbgn`/`clogn` don't have any problem in handling functions.

* `dbgn`/`clogn`, however, can have some problem in case of macros and special forms.

** Some macros such as `when` don't have any problem when used in `dbgn`/`clogn`.

** Other macros such as `defn` which has a binding vector can have problem because they
   have binding symbols which must not be evaluated in `dbgn`/`clogn` macros. In case of
   special forms and those macros in `clojure.core` namespace, `degn`/`clogn` can handle
   them appropriately.

** In some cases, Clojure developers can write their own macros which `dbgn`/`clogn` cannot
   handle appporiately. So I categorized those macros in `clojure.core` namespace as the
   following table and you can register your own macros according to the macro types in
   the table. I will explain it in <<register-macros>>.


[#macro-type-table, cols="^3m,<7m", options="header"]
.Categorized 16 types of macros in `dbgn`/`clogn`
|===

| Macro types | Macros in `clojure.core` and special forms
| :def-type   | def defonce
| :defn-type  | defn defn-
| :fn-type    | fn fn*
| :let-type   | let binding dotimes if-let if-some when-first when-let when-some
                with-in-str with-local-vars with-open with-out-str with-redefs
| :letfn-type | letfn
| :loop-type  | loop
| :for-type   | for doseq
| :case-type  | case
| :skip-arg-1-type     | set! with-precision
| :skip-arg-2-type     | pass:q[as->]
| :skip-arg-1-2-type   |
| :skip-arg-1-3-type   | defmethod
| :skip-arg-2-3-type   | amap areduce
| :skip-form-itself-type  | catch comment declare definline definterface defmacro defmulti
                            defprotocol defrecord defstruct deftype extend-protocol
                            extend-type finally gen-class gen-interface import memfn new
                            ns proxy proxy-super quote refer-clojure reify sync var throw
| :expand-type | pass:q[.. -> ->> doto cond-> cond->> condp import some-> some->>]
| :dot-type    | .

|===


#### `:def-type` example

This type of macros have the first argument which must not be evaluated and can have
optional `doc-string` argument.

[source]
....
(dbgn (def my-function "my-function doc string"
        (fn [x] (* x x x))))

(my-function 10)
; => 1000
....


[listing]
.REPL output
----
dbgn: (def my-function "my-function doc string" (fn [x] (* x x x))) =>
| (fn [x] (* x x x)) =>
|   #function[example.core/eval24554/result--24229--auto----24555]
| (def my-function "my-function doc string" (fn [x] (* x x x))) =>
|   #'example.core/my-function

| x =>
|   10
| x =>
|   10
| x =>
|   10
| (* x x x) =>
|   1000
----


#### `:defn-type` example

This type of macros have the binding vector argument which must not be evaluated and can
have optional `doc-string`, `attr-map`, or `prepost-map` arguments.

[source]
....
(dbgn (defn add
        "add doc string"
        [a b]
        (+ a b)))

(add 10 20)
; => 30
....

[listing]
.REPL output
----
dbgn: (defn add "add doc-string" [a b] (+ a b)) =>

| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30
----

{empty} +


You can debug multiple-arity functions as well.

[source]
....
(dbgn (defn my-add
        "my-add doc string"
        ([] 0)
        ([a] a)
        ([a b] (+ a b))
        ([a b & more] (apply + a b more))))

; The function body in this case doesn't have any symbol to evaluate,
; so no output will be printed.
(my-add)
; => 0

(my-add 10)
; => 10

(my-add 10 20)
; => 30

(my-add 10 20 30 40)
; => 100
....

[listing]
.REPL output
----
dbgn: (defn my-add "my-add doc string" ([] 0) ([a] a) ([a b] (+ a b)) ([a b  ... =>

| a =>
|   10

| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30

| + =>
|   #function[clojure.core/+]
| a =>
|   10
| b =>
|   20
| more =>
|   (30 40)
| (apply + a b more) =>
|   100
----

{empty} +

You can have multiple `dbgn`/``clogn``s.

[source]
....
(dbgn (defn calc1 [a1 a2] (+ a1 a2)))
(dbgn (defn calc2 [s1 s2] (- 100 (calc1 s1 s2))))
(dbgn (defn calc3 [m1 m2] (* 10 (calc2 m1 m2))))

(calc3 2 5)
; => 760
....


[listing]
.REPL output
----
dbgn: (defn calc1 [a1 a2] (+ a1 a2)) =>

dbgn: (defn calc2 [s1 s2] (- 100 (calc1 s1 s2))) =>

dbgn: (defn calc3 [m1 m2] (* 10 (calc2 m1 m2))) =>

| m1 =>
|   2
| m2 =>
|   5

|| s1 =>
||   2
|| s2 =>
||   5

||| a1 =>
|||   2
||| a2 =>
|||   5
||| (+ a1 a2) =>
|||   7
|| (calc1 s1 s2) =>
||   7
|| (- 100 (calc1 s1 s2)) =>
||   93
| (calc2 m1 m2) =>
|   93
| (* 10 (calc2 m1 m2)) =>
|   930
----


#### `:fn-type` example

This type of macros have the binding vector argument which must not be evaluated and can
have optional function name. So it is a little different from `:defn-type` macros.

[source]
....
(dbgn (reduce (fn [acc i] (+ acc i)) 0 [1 5 9]))
; => 15
....

[listing]
.REPL output
----
dbgn: (reduce (fn [acc i] (+ acc i)) 0 [1 5 9]) =>
| (fn [acc i] (+ acc i)) =>
|   #function[example.core/eval25034/result--24229--auto----25035]
| [1 5 9] =>
|   [1 5 9]
| acc =>
|   0
| i =>
|   1
| (+ acc i) =>
|   1
| acc =>
|   1
| i =>
|   5
| (+ acc i) =>
|   6
| acc =>
|   6
| i =>
|   9
| (+ acc i) =>
|   15
| (reduce (fn [acc i] (+ acc i)) 0 [1 5 9]) =>
|   15
----


{empty} +


[source]
.Another example
....
(dbgn (map #(* % 10) [1 5 9]))
; => (10 50 90)
....

[listing]
.REPL output
----
dbgn: (map (fn* [p1__25079#] (* p1__25079# 10)) [1 5 9]) =>
| (fn* [p1__25079#] (* p1__25079# 10)) =>
|   #function[example.core/eval25080/result--24229--auto----25081]
| [1 5 9] =>
|   [1 5 9]
| (map (fn* [p1__25079#] (* p1__25079# 10)) [1 5 9]) =>
|   | p1__25079# =>
|   |   1
|   | (* p1__25079# 10) =>
|   |   10
|   | p1__25079# =>
|   |   5
|   | (* p1__25079# 10) =>
|   |   50
|   | p1__25079# =>
|   |   9
|   | (* p1__25079# 10) =>
|   |   90
|   (10 50 90)
----



#### `:let-type` example

This type of macros have the binding vector argument which must not be evaluated.

[source]
....
(dbgn (let [a (+ 1 2)
            [b c] [(+ a 10) (* a 2)]]
         (- (+ a b) c)))
; => 10
....


[listing]
.REPL output
----
dbgn: (let [a (+ 1 2) [b c] [(+ a 10) (* a 2)]] (- (+ a b) c)) =>
| (+ 1 2) =>
|   3
| a =>
|   3
| (+ a 10) =>
|   13
| a =>
|   3
| (* a 2) =>
|   6
| [(+ a 10) (* a 2)] =>
|   [13 6]
| a =>
|   3
| b =>
|   13
| (+ a b) =>
|   16
| c =>
|   6
| (- (+ a b) c) =>
|   10
| (let [a (+ 1 2) [b c] [(+ a 10) (* a 2)]] (- (+ a b) c)) =>
|   10
----


#### `:letfn-type` example

This type of macro has the special binding vector syntax which is a bit different from
`:fn-type`.

[source]
....
(dbgn (letfn [(twice [x]
                (* x 2))
              (six-times [y]
                (* (twice y) 3))]
        (six-times 15)))
; => 90
....


[listing]
.REPL output
----
dbgn: (letfn [(twice [x] (* x 2)) (six-times [y] (* (twice y) 3))] (six-time ... =>
| y =>
|   15
| x =>
|   15
| (* x 2) =>
|   30
| (twice y) =>
|   30
| (* (twice y) 3) =>
|   90
| (six-times 15) =>
|   90
| (letfn [(twice [x] (* x 2)) (six-times [y] (* (twice y) 3))] (six-time ... =>
|   90
----

#### `:loop-type` example

This type of macro is similiar to `:let-type` but has a significant difference because the `recur` has to be placed at the tail positon with the `loop` form. So it needs a special handling in the implementation of `dbgn`/`clogn`. Refer to <<recur-support>> for details.


#### `:for-type` example

This type of macros have a little different syntax from `:let-type` macros, because it
can have `:let`, `:when`, or `:while` clause.

[source]
....
(dbgn (for [x [0 1 2 3 4 5]
            :let [y (* x 3)]
            :when (even? y)]
        y))
; => (0 6 12)
....


[listing]
.REPL output
----
dbgn: (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) =>
| [0 1 2 3 4 5] =>
|   [0 1 2 3 4 5]
| (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) =>
|   | x =>
|   |   0
|   | (* x 3) =>
|   |   0
|   | y =>
|   |   0
|   | (even? y) =>
|   |   true
|   | y =>
|   |   0
|   | x =>
|   |   1
|   | (* x 3) =>
|   |   3
|   | y =>
|   |   3
|   | (even? y) =>
|   |   false
|   | x =>
|   |   2
|   | (* x 3) =>
|   |   6
|   | y =>
|   |   6
|   | (even? y) =>
|   |   true
|   | y =>
|   |   6
|   | x =>
|   |   3
|   | (* x 3) =>
|   |   9
|   | y =>
|   |   9
|   | (even? y) =>
|   |   false
|   | x =>
|   |   4
|   | (* x 3) =>
|   |   12
|   | y =>
|   |   12
|   | (even? y) =>
|   |   true
|   | y =>
|   |   12
|   | x =>
|   |   5
|   | (* x 3) =>
|   |   15
|   | y =>
|   |   15
|   | (even? y) =>
|   |   false
|   (0 6 12)
----


#### `:case-type` example

This type of macro has the special syntax. Refer to
https://clojuredocs.org/clojure.core/case[here] about details.

[source]
....
(dbgn (let [mystr "hello"]
        (case mystr
          "" 0
          "hello" (count mystr))))
; => 5
....


[listing]
.REPL output
----
dbgn: (let [mystr "hello"] (case mystr  0 hello (count mystr))) =>
| mystr =>
|   "hello"
| mystr =>
|   "hello"
| (count mystr) =>
|   5
| (case mystr "" 0 "hello" (count mystr)) =>
|   5
| (let [mystr "hello"] (case mystr "" 0 "hello" (count mystr))) =>
|   5
----

{empty} +


[source]
.Another example
....
(dbgn (case 'a
        (x y z) "x, y, or z"
        "default"))
; => "default"
....

[listing]
.REPL output
----
dbgn: (case (quote a) (x y z) "x, y, or z" "default") =>
| (case (quote a) (x y z) "x, y, or z" "default") =>
|   "default"
----


#### `:skip-arg-1-type` example

This type of macros have the first argument which must not be evaluated. So `dbgn`/`clogn`
internally skips the evaluation of this argument.

[source]
....
(dbgn (with-precision 10 (/ 1M 6)))
; => 0.1666666667M
....


[listing]
.REPL output
----
dbgn: (with-precision 10 (/ 1M 6)) =>
| (/ 1M 6) =>
|   0.1666666667M
| (with-precision 10 (/ 1M 6)) =>
|   0.1666666667M
----

#### `:skip-arg-2-type` example

This type of macros have the second argument which must not be evaluated. So `dbgn`/`clogn`
internally skips the evaluation of this argument.

[source]
....
(dbgn (as-> 0 n
        (inc n)
        (inc n)))
; => 2
....


[listing]
.REPL output
----
dbgn: (as-> 0 n (inc n) (inc n)) =>
| n =>
|   0
| (inc n) =>
|   1
| n =>
|   1
| (inc n) =>
|   2
| (as-> 0 n (inc n) (inc n)) =>
|   2
----


#### `:skip-arg-1-2-type` example

This type of macros have the first and second arguments which must not be evaluated. So
`dbgn`/`clogn` internally skips the evaluation of those arguments. However, I can't find this
type of macros in `clojure.core` namespace but add this type for completeness and the
future possibilities of this type of macros.


#### `:skip-arg-1-3-type` example

This type of macros have the first and third arguments which must not be evaluated. So
`dbgn`/`clogn` internally skips the evaluation of those arguments.

[source]
....
(defmulti greeting
  (fn [x] (:language x)))

(dbgn (defmethod greeting :english [map]
        (str "English greeting: " (:greeting map))))

(dbgn (defmethod greeting :french [map]
        (str "French greeting: " (:greeting map))))

(def english-map {:language :english :greeting "Hello!"})
(def french-map {:language :french :greeting "Bonjour!"})

(greeting english-map)
(greeting french-map)
....


[listing]
.REPL output
----
dbgn: (defmethod greeting :english [map] (str "English greeting: " (:greetin ... =>
| (defmethod greeting :english [map] (str "English greeting: " (:greeting map))) =>
|   #multifn[greeting 0x1c28c1cc]

dbgn: (defmethod greeting :french [map] (str "French greeting: " (:greeting  ... =>
| (defmethod greeting :french [map] (str "English greeting: " (:greeting map))) =>
|   #multifn[greeting 0x1c28c1cc]

| map =>
|   {:language :english, :greeting "Hello!"}
| (:greeting map) =>
|   "Hello!"
| (str "English greeting: " (:greeting map)) =>
|   "English greeting: Hello!"

| map =>
|   {:language :french, :greeting "Bonjour!"}
| (:greeting map) =>
|   "Bonjour!"
| (str "French greeting: " (:greeting map)) =>
|   "French greeting: Bonjour!"
----


#### `:skip-arg-2-3-type` example

This type of macros have the second and third arguments which must not be evaluated. So
`dbgn`/`clogn` internally skips the evaluation of those arguments.


[source]
....
(let [xs (float-array [1 2 3])]
  (dbgn (areduce xs i ret (float 0)
                 (+ ret (aget xs i)))))
; => 6.0
....


[listing]
.REPL output
----
dbgn: (areduce xs i ret (float 0) (+ ret (aget xs i))) =>
| xs =>
|   [1.0, 2.0, 3.0]
| (float 0) =>
|   0.0
| ret =>
|   0.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   0
| (aget xs i) =>
|   1.0
| (+ ret (aget xs i)) =>
|   1.0
| ret =>
|   1.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   1
| (aget xs i) =>
|   2.0
| (+ ret (aget xs i)) =>
|   3.0
| ret =>
|   3.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   2
| (aget xs i) =>
|   3.0
| (+ ret (aget xs i)) =>
|   6.0
| (areduce xs i ret (float 0) (+ ret (aget xs i))) =>
|   6.0
----


#### `:skip-form-itself-type` example

This type of macros have too complex to parse, so `dbgn`/`clogn` skips the form itself and does
nothing.


#### `:expand-type` example

This type of macros will be expanded and then the output will be printed.

[source]
....
(dbgn (-> "a b c d"
          .toUpperCase
          (.replace "A" "X")
          (.split " ")
          first))
; => "X"
....

[listing]
.REPL output
----
dbgn: (-> "a b c d" .toUpperCase (.replace "A" "X") (.split " ") first) =>
| (.toUpperCase "a b c d") =>
|   "A B C D"
| (.replace (.toUpperCase "a b c d") "A" "X") =>
|   "X B C D"
| (.split (.replace (.toUpperCase "a b c d") "A" "X") " ") =>
|   ["X", "B", "C", "D"]
| (first (.split (.replace (.toUpperCase "a b c d") "A" "X") " ")) =>
|   "X"
----


{empty} +


[source]
.Another example
....
(dbgn (.. "fooBAR"  toLowerCase  (contains "ooba")))
; => true
....


[listing]
.REPL output
----
dbgn: (.. "fooBAR" toLowerCase (contains "ooba")) =>
| (. "fooBAR" toLowerCase) =>
|   "foobar"
| (. (. "fooBAR" toLowerCase) (contains "ooba")) =>
|   true
----

{empty} +

[source]
.Yet another example
....
(let [x 1 y 2]
  (dbgn (cond-> []
          (odd? x) (conj "x is odd")
          (zero? (rem y 3)) (conj "y is divisible by 3")
          (even? y) (conj "y is even"))))
; => ["x is odd" "y is even"]
....

[listing]
.REPL output
----
dbgn: (cond-> [] (odd? x) (conj "x is odd") (zero? (rem y 3)) (conj "y is di ... =>
| [] =>
|   []
| x =>
|   1
| (odd? x) =>
|   true
| G__25146 =>
|   []
| (conj G__25146 "x is odd") =>
|   ["x is odd"]
| (if (odd? x) (conj G__25146 "x is odd") G__25146) =>
|   ["x is odd"]
| y =>
|   2
| (rem y 3) =>
|   2
| (zero? (rem y 3)) =>
|   false
| G__25146 =>
|   ["x is odd"]
| (if (zero? (rem y 3)) (conj G__25146 "y is divisible by 3") G__25146) =>
|   ["x is odd"]
| y =>
|   2
| (even? y) =>
|   true
| G__25146 =>
|   ["x is odd"]
| (conj G__25146 "y is even") =>
|   ["x is odd" "y is even"]
| (if (even? y) (conj G__25146 "y is even") G__25146) =>
|   ["x is odd" "y is even"]
| (clojure.core/let [G__28483 [] G__28483 (if (odd? x) (conj G__28483 "x ... =>
|   ["x is odd" "y is even"]
----


#### `:dot-type` example

[source]
....
(dbgn (. (java.util.Date.) getMonth))
; => 5
....


[listing]
.REPL output
----
dbgn: (. (java.util.Date.) getMonth) =>
| (java.util.Date.) =>
|   #inst "2017-06-27T08:04:46.480-00:00"
| (. (java.util.Date.) getMonth) =>
|   5
----


[#recur-support]
### Limited support for the form including `recur`

[cols="^1m,^1m,^1m", options="header"]
.The forms including `recur`
|===

|                        | dbgn  | clogn
| loop ~ recur           |   O   |   O
| defn/defn-/fn ~ recur  |  △   |  △

|===

* Legend: `O` (supported), `△` (limitedly supported)

#### `loop` ~ `recur`

You can see the evaluated results of the form which incldues `loop` ~ `recur` by using
`dbgn` in Clojure and ClojureScript.

[source]
....
(dbgn (loop [acc 1 n 3]
        (if (zero? n)
          acc
          (recur (* acc n) (dec n)))))
; => 6
....

.REPL output
[listing]
----
dbgn: (loop [acc 1 n 3] (if (zero? n) acc (recur (* acc n) (dec n)))) =>
| n =>
|   3
| (zero? n) =>
|   false
| acc =>
|   1
| n =>
|   3
| (* acc n) =>
|   3
| n =>
|   3
| (dec n) =>
|   2
| n =>
|   2
| (zero? n) =>
|   false
| acc =>
|   3
| n =>
|   2
| (* acc n) =>
|   6
| n =>
|   2
| (dec n) =>
|   1
| n =>
|   1
| (zero? n) =>
|   false
| acc =>
|   6
| n =>
|   1
| (* acc n) =>
|   6
| n =>
|   1
| (dec n) =>
|   0
| n =>
|   0
| (zero? n) =>
|   true
| acc =>
|   6
| (loop [acc 1 n 3] (if (zero? n) acc (recur (* acc n) (dec n)))) =>
|   6
----

{empty} +

[source]
.Another example
....
(dbgn (defn fact [num]
        (loop [acc 1 n num]
          (if (zero? n)
            acc
            (recur (* acc n) (dec n))))))

(fact 3)
....


[listing]
.REPL output
----
dbgn: (defn fact [num] (loop [acc 1 n num] (if (zero? n) acc (recur (* acc n ... =>

| num =>
|   3
| n =>
|   3
| (zero? n) =>
|   false
| acc =>
|   1
| n =>
|   3
| (* acc n) =>
|   3
| n =>
|   3
| (dec n) =>
|   2
| n =>
|   2
| (zero? n) =>
|   false
| acc =>
|   3
| n =>
|   2
| (* acc n) =>
|   6
| n =>
|   2
| (dec n) =>
|   1
| n =>
|   1
| (zero? n) =>
|   false
| acc =>
|   6
| n =>
|   1
| (* acc n) =>
|   6
| n =>
|   1
| (dec n) =>
|   0
| n =>
|   0
| (zero? n) =>
|   true
| acc =>
|   6
| (loop [acc 1 n num] (if (zero? n) acc (recur (* acc n) (dec n)))) =>
|   6
----



#### `defn`/`defn-`/`fn` ~ `recur` without `loop`

IMPORTANT: If you use `dbgn` in `defn`/`defn-`/`fn` ~ `recur` form without `loop`, you
will have the following exception. I am sorry about it, but this is inevitable due to the
implementation restriction.


[source]
....
(dbgn (defn factorial [acc n]
        (if (zero? n)
          acc
          (recur (* acc n) (dec n)))))
....

.REPL output
[listing]
----
1. Caused by java.lang.UnsupportedOperationException
   Cannot recur across try
----

{empty} +

TIP: However, if you *temporarily* replace `recur` with `function name` itself, you can
debug the form as follows. *Be careful* not to forget to recover `function name` itself to
`recur` after debugging.

[source]
....
(dbgn (defn factorial [acc n]
        (if (zero? n)
          acc
          (factorial (* acc n) (dec n)))))

(factorial 1 3)
....

.REPL output
[listing]
----
dbgn: (defn factorial [acc n] (if (zero? n) acc (factorial (* acc n) (dec n) ... =>

| n =>
|   3
| (zero? n) =>
|   false
| acc =>
|   1
| n =>
|   3
| (* acc n) =>
|   3
| n =>
|   3
| (dec n) =>
|   2

|| n =>
||   2
|| (zero? n) =>
||   false
|| acc =>
||   3
|| n =>
||   2
|| (* acc n) =>
||   6
|| n =>
||   2
|| (dec n) =>
||   1

||| n =>
|||   1
||| (zero? n) =>
|||   false
||| acc =>
|||   6
||| n =>
|||   1
||| (* acc n) =>
|||   6
||| n =>
|||   1
||| (dec n) =>
|||   0

|||| n =>
||||   0
|||| (zero? n) =>
||||   true
|||| acc =>
||||   6
|||| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
||||   6
||| (factorial (* acc n) (dec n)) =>
|||   6
||| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
|||   6
|| (factorial (* acc n) (dec n)) =>
||   6
|| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
||   6
| (factorial (* acc n) (dec n)) =>
|   6
| (if (zero? n) acc (factorial (* acc n) (dec n))) =>
|   6
----


[#register-macros]
### How to register your own macros in using `dbgn`/`clogn`

* If you have some error when analyzing some source code using `dbgn`/`clogn`, first
  of all, you have to figure out what kind of macro (refer to <<macro-type-table>>) caused
  the error and then register the macro by using `register-macros!`.

* You can see the registered macros by using `show-macros`.


[source]
.API format
....
(register-macros! macro-type macros)

(show-macros)
(show-macros macro-type)
....

#### Clojure example

[source]
.example/core.clj
....
(ns example.core)

(use 'debux.core)

(defmacro my-let [bindings & body]
  `(let ~bindings ~@body))

;; Registering your own macro
(register-macros! :let-type [my-let])

(dbg (show-macros :let-type))
(dbg (show-macros))

(dbgn (my-let [a 10 b (+ a 10)] (+ a b)))
....


[listing]
.REPL output
----
dbg: (show-macros :let-type) =>
|   {:let-type
|    #{clojure.core/when-let example.dbgn/my-let clojure.core/let
|      clojure.core/with-local-vars clojure.core/if-let
|      clojure.core/when-some clojure.core/dotimes clojure.core/with-open
|      clojure.core/if-some clojure.core/with-redefs clojure.core/binding
|      clojure.core/with-in-str clojure.core/with-out-str clojure.core/loop
|      clojure.core/when-first}}

dbg: (show-macros) =>
|   {:fn-type #{clojure.core/fn fn*},
|    :skip-form-itself-type
|    #{clojure.core/proxy-super clojure.core/defmacro
|      clojure.core/definterface clojure.core/sync clojure.core/defrecord
|      clojure.core/declare clojure.core/deftype clojure.core/comment
|      finally clojure.core/gen-class clojure.core/refer-clojure
|      clojure.core/memfn clojure.core/extend-type new
|      clojure.core/definline clojure.core/defstruct clojure.core/defmulti
|      clojure.core/ns clojure.core/proxy clojure.core/extend-protocol var
|      quote clojure.core/reify catch clojure.core/gen-interface
|      clojure.core/import clojure.core/defprotocol throw},
|    :case-type #{clojure.core/case},
|    :skip-arg-2-3-type #{clojure.core/areduce clojure.core/amap},
|    :skip-arg-1-type #{clojure.core/with-precision set!},
|    :let-type
|    #{clojure.core/when-let example.dbgn/my-let clojure.core/let
|      clojure.core/with-local-vars clojure.core/if-let
|      clojure.core/when-some clojure.core/dotimes clojure.core/with-open
|      clojure.core/if-some clojure.core/with-redefs clojure.core/binding
|      clojure.core/with-in-str clojure.core/with-out-str clojure.core/loop
|      clojure.core/when-first},
|    :skip-arg-2-type #{clojure.core/as->},
|    :defn-type #{clojure.core/defn clojure.core/defn-},
|    :loop-type #{clojure.core/loop},
|    :for-type #{clojure.core/for clojure.core/doseq},
|    :def-type #{clojure.core/defonce def},
|    :letfn-type #{clojure.core/letfn},
|    :dot-type #{.},
|    :skip-arg-1-2-type #{},
|    :expand-type
|    #{clojure.core/doto clojure.core/->> clojure.core/some->>
|      clojure.core/.. clojure.core/-> clojure.core/some->
|      clojure.core/cond-> clojure.core/condp clojure.core/import
|      clojure.core/cond->>},
|    :skip-arg-1-3-type #{clojure.core/defmethod}}

dbgn: (my-let [a 10 b (+ a 10)] (+ a b)) =>
| a =>
|   10
| (+ a 10) =>
|   20
| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30
| (my-let [a 10 b (+ a 10)] (+ a b)) =>
|   30
----


#### ClojureScript example

[source]
.example/macro.clj
....
(ns example.macro)

(defmacro my-let [bindings & body]
  `(let ~bindings ~@body))
....


[source]
.example/core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]])
  (:require-macros [example.macro :refer [my-let]]))

;; Registering your own macro
(d/register-macros! :let-type [my-let])

(dbg (d/show-macros :let-type))
(dbg (d/show-macros))

(clogn (my-let [a 10 b (+ a 10)] (+ a b)))
....


[listing]
.Output
----
dbg: (d/show-macros :let-type) =>
|   {:let-type
|    #{example.macro/my-let cljs.core/with-redefs cljs.core/binding
|      cljs.core/when-first
|      cljs.core/if-some
|      cljs.core/let
|      cljs.core/with-out-str
|      cljs.core/loop
|      cljs.core/when-let
|      cljs.core/when-some cljs.core/if-let cljs.core/dotimes}}

dbg: (d/show-macros) =>
|   {:fn-type #{fn* cljs.core/fn},
|    :skip-form-itself-type
|    #{cljs.core/defmulti finally cljs.core/defprotocol
|      cljs.core/extend-protocol
|      new
|      cljs.core/import
|      cljs.core/defrecord
|      cljs.core/declare
|      cljs.core/reify
|      cljs.core/deftype
|      cljs.core/comment
|      cljs.core/memfn
|      var
|      quote
|      cljs.core/refer-clojure
|      catch
|      cljs.core/extend-type
|      throw
|      cljs.core/defmacro},
|    :case-type #{cljs.core/case},
|    :skip-arg-2-3-type #{cljs.core/amap cljs.core/areduce},
|    :skip-arg-1-type #{set!},
|    :let-type
|    #{example.macro/my-let cljs.core/with-redefs cljs.core/binding
|      cljs.core/when-first
|      cljs.core/if-some
|      cljs.core/let
|      cljs.core/with-out-str
|      cljs.core/loop
|      cljs.core/when-let
|      cljs.core/when-some
|      cljs.core/if-let
|      cljs.core/dotimes},
|    :skip-arg-2-type #{cljs.core/as->},
|    :defn-type #{cljs.core/defn- cljs.core/defn},
|    :loop-type #{cljs.core/loop},
|    :for-type #{cljs.core/doseq cljs.core/for},
|    :def-type #{cljs.core/defonce def},
|    :letfn-type #{cljs.core/letfn},
|    :dot-type #{.},
|    :skip-arg-1-2-type #{},
|    :expand-type
|    #{cljs.core/.. cljs.core/some-> cljs.core/-> cljs.core/cond->>
|      cljs.core/import
|      cljs.core/doto
|      cljs.core/condp
|      cljs.core/cond->
|      cljs.core/some->>
|      cljs.core/->>},
|    :skip-arg-1-3-type #{cljs.core/defmethod}}
----

image::register-macros.png[title="register-macros! example", width=600]


[#mixed-use]
## Mixed use of `dbg` and `dbgn`

`dbg` can be used inside `dbgn` or vice versa since the version 0.4.2. If you want to see
the printed results of pass:q[`->`], pass:q[`->>`], `let` or `comp` in `dbg` when using
`dbgn`, do it like this.

[source]
....
(defn my-fun [a b c]
  (dbgn (+ a b c
           (dbg (->> (range (- b a))
                     (map #(* % %))
                     (filter even?)
                     (take a)
                     (reduce +))))))

(my-fun 10 20 100)
....

[listing]
.REPL output:
----
dbgn: (+ a b c (dbg (->> (range (- b a)) (map (fn* [p1__16770#] (* p1__16770 ... =>
| a =>
|   10
| b =>
|   20
| c =>
|   100

dbg: (->> (range (- b a)) (map (fn* [p1__16770#] (* p1__16770# p1__16770#)) ... =>
| (range (- b a)) =>
|   (0 1 2 3 4 5 6 7 8 9)
| (map (fn* [p1__16770#] (* p1__16770# p1__16770#))) =>
|   (0 1 4 9 16 25 36 49 64 81)
| (filter even?) =>
|   (0 4 16 36 64)
| (take a) =>
|   (0 4 16 36 64)
| (reduce +) =>
|   120
| (+ a b c (dbg (->> (range (- b a)) (map (fn* [p1__16770#] (* p1__16770 ... =>
|   250
----


[#browser-repl]
## Usage in ClojureScript on Browser REPL

You can use both `dbg`/`dbgn` and `clog`/`clogn` on the browser REPL. The following is
an example about running the link:https://github.com/bhauman/lein-figwheel[figwheel].

[source]
.project.clj
....
(defproject example "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [org.clojure/clojurescript "1.9.854"]
                 [philoskim/debux "0.4.2"]]
  :plugins [[lein-cljsbuild "1.1.6"]
            [lein-figwheel  "0.5.10"]]
  :source-paths ["src/clj"]
  :clean-targets ^{:protect false}
                 ["resources/public/js/app.js"
                  "resources/public/js/app.js.map"]
  :cljsbuild {:builds [{:id "dev"
                        :source-paths ["src/cljs"]
                        :figwheel true
                        :compiler {:main example.core
                                   :asset-path "js/out"
                                   :output-to "resources/public/js/app.js"
                                   :output-dir "resources/public/js/out"
                                   :source-map true
                                   :optimizations :none} }]})
....


And then run figwheel like this on terminal window.


[listing]
----
$ lein figwheel
Figwheel: Cutting some fruit, just a sec ...
Figwheel: Validating the configuration found in project.clj
Figwheel: Configuration Valid :)
Figwheel: Starting server at http://0.0.0.0:3449
Figwheel: Watching build - dev
Compiling "resources/public/js/app.js" from ["src/cljs"]...
Successfully compiled "resources/public/js/app.js" in 2.14 seconds.
Launching ClojureScript REPL for build: dev
Figwheel Controls:
          (stop-autobuild)                ;; stops Figwheel autobuilder
          (start-autobuild [id ...])      ;; starts autobuilder focused on optional ids
          (switch-to-build id ...)        ;; switches autobuilder to different build
          (reset-autobuild)               ;; stops, cleans, and starts autobuilder
          (reload-config)                 ;; reloads build config and resets autobuild
          (build-once [id ...])           ;; builds source one time
          (clean-builds [id ..])          ;; deletes compiled cljs target files
          (print-config [id ...])         ;; prints out build configurations
          (fig-status)                    ;; displays current state of system
          (figwheel.client/set-autoload false)    ;; will turn autoloading off
          (figwheel.client/set-repl-pprint false) ;; will turn pretty printing off
  Switch REPL build focus:
          :cljs/quit                      ;; allows you to switch REPL to another build
    Docs: (doc function-name-here)
    Exit: Control+C or :cljs/quit
 Results: Stored in vars *1, *2, *3, *e holds last exception object
Prompt will show when Figwheel connects to your application
----

After that, connect to `http://localhost:3449` on your browser.

[listing]
----
To quit, type: :cljs/quit
cljs.user=> (require '[debux.cs.core :refer-macros [clog clogn dbg dbgn break]])
nil

cljs.user=> (dbg (+ 1 2))

dbg: (+ 1 2) =>
|   3
3

cljs.user=>
----

Now you can do anything in this browser REPL as in the Clojure REPL. When you evaluate
`dbg`/`dbgn` in your ClojureScript source code, the result will go to both the REPL window
and the browser's console window. When you evaluate `clog`/`clogn` in your ClojureScript
source code, the result will go only to your browser's console window.


## License
Copyright © 2015--2018 Young Tae Kim

Distributed under the Eclipse Public License either version 1.0 or any later version.
